==Technology==
===Description===
- Remote service interfaces uses the GWT @RemoteServiceRelativePath annotation to uniquely define
their endpoint. A interface marked with @RemoteServiceRelativePath("myService") and using service
root "Application" will cause GWT to connect to "/Application/myService.rpc". The service root is
specified in Application.gwt.xml as the value of the rename-to attribute.

- The application uses a variety of Spring technologies:
*** ContextLoaderListener is used to load Spring beans specified via the contextConfigLocation
value (in web.xml).
*** DispatcherServlet is used to perform dependency injection in the GWT remote service
implementations. This is done by mapping the DispatcherServlet to intercept all *.rpc URLs. Causing
Spring to look for the handler file "WEB-INF/${dispatcher-servlet-name}-servlet.xml". This file
contains URL handlers (mappings between URLs and Spring beans) thus the mapping
"*/Application/myService.rpc=ServiceBean" causes all requests to "/Application/myService.rpc" to be
served by "ServiceBean". As the GWT remote service implementation ("ServiceBean") is now created by
Spring it's eligible for the full back of Spring tricks (DI, AOP...).
*** All remote service implementations uses Spring's @Service annotation to uniquely mark them as
Spring beans so they can be referenced in the DispatcherServlet handlers.

- The Application.gwt.xml configures you GWT client application. It specifies:
*** rename-to (ServiceRoot):
1)  Application.gwt.xml specifies application entry point. This is the class that is first loaded when user enters the site.
2) GWT compiles the classes defined in WebApp.gwt.xml (Entrypoint...) into JavaScript.
--> The produced JavaScript is referenced from a file called nocache.js.
--> The actual path to nocache.js is controlled by  Application.gwt.xml's "rename-to" attribute. For instance,
    the value rename-to="webapp" will produce "webapp/nocache.js".
--> Our main page (index.html) includes "webapp/nocache.js" (this way the application starts)
*** Module inheritance. Using the "inherits" element we can access functionality (widgets, logging..)
implemented elsewhere. Usually we at least inherit "com.google.gwt.user.User" which contains the core
GWT widgets.
*** EntryPoint: The "main" class of the GWT client application, containing the "onModuleLoad" method
that starts the application. This class is compiled into browser specific JavaScript referenced from
the Application.nocache.js file. This JavaScript file is turn used by the Application.html page,
accessed by the user.


===GWT===
GWT XSDs are downloaded from:
* UiBinder.xsd: http://dl.google.com/gwt/dtd/uibinder.xsd
---> For UI composition, such as importing templates, CSS, images,...
* com.google.gwt.user.client.ui.xsd: http://dl.google.com/gwt/dtd/com.google.gwt.user.client.ui.xsd
---> For standard GWT panels and widgets

Messages:
- Use com.google.gwt.i18n.client.Messages when you have messages that accepts parameters (for instance,
"Error {0} account does not have access to {1}").
- Use com.google.gwt.i18n.client.Constants when you messages are constants (i.e. have no parameters)

==Panels==
* HTMLPanel = TODO is it a div ?


====Annotations====
@Shared
* UI Elements
---> @UiTemplate: TODO describe (Must be visible in class when used on field)
---> @UiField: TODO describe (Must be visible in class when used on field)
---> @UiFactory
---> @UiConstructor: Get constructor value from ui template file
* CSS
---> only works for reusable CSS elements (i.e. classes, not id's)
---> In the CSS, a class selector is a name preceded by a full stop (.) and an ID selector is a name preceded by a hash character (#).
---> @external: Create Java name for CSS style to reference from code (for convenience call it the same as CSS class) but don't obfuscate it
---> styles included in CssResource are obfuscated (i.e stylesheet is removed and they can be programmed against differnt browsers)
* Messages
---> Use @Key("msgPropertyName") to map from a Message property to a specific java property (if @key is left out then text prop
is assumed to have same name as java property)

- For convince we require the XML UI files to be backed by a implementing class, matching its name in CamelCase
(for instance, login.ui.xml is backed by LoginUi.java)




